use crate::data_types::{
    self, handshake_next_state::HandshakeNextState, registry_data_entry::Entry, Boolean,
    Identifier, VarInt,
};

pub(crate) struct RawPacket {
    /// Length of Packet ID + Data
    length: VarInt,
    packet_id: VarInt,
    data: Vec<u8>,
}

/// Serverbound Packets
pub enum ClientPacket {
    /// Packet may only be used at connection state: `Handshaking`
    Handshake {
        protocol_version: VarInt,
        server_address: String,
        server_port: u16,
        next_state: HandshakeNextState,
    },
    /// Packet may only be used at connection state: `Handshaking`
    LegacyServerListPing {
        /// always `0x01`
        payload: u8,
    },
    /// The status can only be requested once immediately after the handshake, before any ping. The server won't respond otherwise.
    ///
    /// ---
    ///
    /// Packet may only be used at connection state: `Status`
    StatusRequest,
    /// Packet may only be used at connection state: `Status`
    PingRequestAtStatus {
        /// May be any number
        payload: i64,
    },
    /// Packet may only be used at connection state: `Login`
    LoginStart {
        /// The player's username
        name: data_types::String,
        /// The player's UUID
        player_uuid: uuid::Uuid,
    },
    /// Packet may only be used at connection state: `Login`
    EncryptionResponse {
        /// Length in bytes of the shared secret
        shared_secret_length: VarInt,
        /// Shared secret value, encrypted with the server's public key
        shared_secret: Vec<u8>,
        /// Length in bytes of the verify token
        verify_token_length: VarInt,
        /// Verify token value, encrypted with the same public key as the shared secret
        verify_token: Vec<u8>,
    },
    /// Packet may only be used at connection state: `Login`
    LoginPluginResponse {
        /// Should match the `message_id` from the [`ServerPacket::LoginPluginRequest`]
        message_id: VarInt,
        /// Whether the client understood the request. When false, no payload follows.
        successful: Boolean,
        /// Any data, depending on the channel. The length of this array must be inferred from the packet length.
        ///
        /// ---
        ///
        /// Not present if `successful` is false.
        data: Option<Vec<u8>>,
    },
    /// Acknowledgement to the Login Success packet sent by the server.
    ///
    /// ---
    ///
    /// This packet switches the connection state to configuration.
    /// Packet may only be used at connection state: `Login`
    LoginAknowledged,
    /// Response to a [Cookie Request](ServerPacket::CookieRequest) from the server.
    ///
    /// ---
    ///
    /// The Notchian server only accepts responses of up to 5 kiB in size.
    ///
    /// ---
    ///
    /// Packet may only be used at connection state: `Login`
    CookieResponseAtLogin {
        /// The identifier of the cookie
        key: data_types::Identifier,
        /// The payload of the cookie
        payload: Option<Vec<u8>>,
    },
}

/// Clientbound Packets
pub enum ServerPacket {
    /// Packet may only be used at connection state: `Status`
    StatusResponse {
        /// See [Server List Ping - Status Response](https://wiki.vg/Server_List_Ping#Status_Response)
        json_response: data_types::String,
    },
    /// Packet may only be used at connection state: `Status`
    PingResponseAtStatus {
        /// Should be the same as the `payload` from the [`ClientPacket::PingRequest`]
        payload: i64,
    },
    /// Packet may only be used at connection state: `Login`
    DisconnectAtLogin {
        /// Reason for disconnection
        reason: data_types::String,
    },
    /// Packet may only be used at connection state: `Login`
    EncryptionRequest {
        /// Appears to be empty
        server_id: data_types::String,
        /// Length in bytes of the public key
        public_key_length: VarInt,
        /// Server's public key, in bytes
        public_key: Vec<u8>,
        /// Length of Verify Token. Always 4 for notchian servers
        verify_token_length: VarInt,
        /// A sequence of random bytes generated by the server
        verify_token: Vec<u8>,
        /// Wheather the client should attempt to [authenticate through mojang servers](https://wiki.vg/Protocol_Encryption#Authentication)
        should_authenticate: Boolean,
    },
    /// Packet may only be used at connection state: `Login`
    LoginSuccess {
        uuid: uuid::Uuid,
        username: data_types::String,
        number_of_properties: VarInt,
        properties: Vec<data_types::property::Property>,
        strict_error_handling: Boolean,
    },
    /// Enables compression.
    ///
    /// ---
    ///
    /// Negative values will disable compression, meaning the packet format should remain in the uncompressed packet format.
    /// However, this packet is entirely optional, and if not sent, compression will also not be enabled
    ///
    /// ---
    ///
    /// Packet may only be used at connection state: `Login`
    SetCompression {
        /// Maximum size of a packet before it is compressed
        threshold: VarInt,
    },
    /// Used to implement a custom handshaking flow together with Login Plugin Response.
    ///
    /// ---
    ///
    /// Unlike plugin messages in "play" mode,
    /// these messages follow a lock-step request/response scheme,
    /// where the client is expected to respond to a request indicating whether it understood.
    /// The notchian client always responds that it hasn't understood,
    /// and sends an empty payload.
    ///
    /// ---
    /// Packet may only be used at connection state: `Login`
    LoginPluginRequest {
        /// Generated by the server - should be unique to the connection.
        message_id: VarInt,
        /// Name of the [plugin channel](https://wiki.vg/Plugin_channel) used to send the data.
        channel: data_types::Identifier,
        /// Any data, depending on the channel. The length of this array must be inferred from the packet length.
        data: Vec<u8>,
    },
    /// Packet may only be used at connection state: `Login`
    CookieRequestAtLogin { key: data_types::Identifier },
    /// Packet may only be used at connection state: `Configuration`
    CookieRequestAtConfiguration { key: data_types::Identifier },
    /// Mods and plugins can use this to send their data.
    /// Minecraft itself uses several plugin channels.
    /// These internal channels are in the minecraft namespace.
    ///
    /// More information on how it works on Dinnerbone's blog.
    /// More documentation about internal and popular registered channels are here.
    ///
    /// ---
    ///
    /// Packet may only be used at connection state: `Configuration`
    PluginMessageAtConfiguration {
        /// Name of the [plugin channel](https://wiki.vg/Plugin_channel) used to send the data.
        channel: data_types::Identifier,
        /// Any data, depending on the channel. The length of this array must be inferred from the packet length.
        data: Vec<u8>,
    },
    /// Packet may only be used at connection state: `Configuration`
    DisconnectAtConfiguration {
        /// Reason for disconnection
        reason: data_types::String,
    },
    /// Sent by the server to notify the client that the configuration process has finished.
    /// The client answers with [Acknowledge Finish Configuration](ClientPacket::AcknoledgeFinishConfiguration) whenever it is ready to continue.
    ///
    /// ---
    ///
    /// This packet switches the connection state to play.
    ///
    /// ---
    ///
    /// Packet may only be used at connection state: `Configuration`
    FinishConfiguration,
    /// The server will frequently send out a keep-alive, each containing a random ID.
    /// The client must respond with the same payload (see Serverbound Keep Alive).
    /// If the client does not respond to a Keep Alive packet within 15 seconds after it was sent, the server kicks the client.
    /// Vice versa, if the server does not send any keep-alives for 20 seconds, the client will disconnect and yields a "Timed out" exception.
    ///
    /// The Notchian server uses a system-dependent time in milliseconds to generate the keep alive ID value.
    ///
    /// ---
    ///
    /// Packet may only be used at connection state: `Configuration`
    KeepAliveAtConfiguration { payload: i64 },
    /// Packet is not used by the Notchian server.
    /// When sent to the client, client responds with a Pong packet with the same id.
    ///
    /// ---
    ///
    /// Packet may only be used at connection state: `Configuration`
    PingAtConfiguration { id: i32 },
    /// Packet may only be used at connection state: `Configuration`
    ResetChat,
    RegistryData {
        registry_id: Identifier,
        entries: Vec<Entry>,
    },
    /// Packet may only be used at connection state: `Configuration`
    RemoveResourcePackAtConfiguration { uuid: Option<uuid::Uuid> },
}
